<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Redis,事件驱动," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Redis服务器是一个单线程服务器，利用I/O多路复用技术实现了一个事件驱动框架。代码在ae.h、ae.c以及ae_epoll.c、ae_evport.c和ae_kqueue.c、ae_select.c这几个文件中。其中ae表示的是antirez eventloop的意思。Redis利用Reactor模式，开发了自己的网络事件处理器，利用I/O多路复用技术监听多个套接字。此框架既实现了高性能的网络">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis中的事件驱动模型">
<meta property="og:url" content="http://gmshepard.github.io/2017/03/15/Redis中的事件驱动模型/index.html">
<meta property="og:site_name" content="gmshepard's tech blog">
<meta property="og:description" content="Redis服务器是一个单线程服务器，利用I/O多路复用技术实现了一个事件驱动框架。代码在ae.h、ae.c以及ae_epoll.c、ae_evport.c和ae_kqueue.c、ae_select.c这几个文件中。其中ae表示的是antirez eventloop的意思。Redis利用Reactor模式，开发了自己的网络事件处理器，利用I/O多路复用技术监听多个套接字。此框架既实现了高性能的网络">
<meta property="og:updated_time" content="2017-08-06T14:26:53.066Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis中的事件驱动模型">
<meta name="twitter:description" content="Redis服务器是一个单线程服务器，利用I/O多路复用技术实现了一个事件驱动框架。代码在ae.h、ae.c以及ae_epoll.c、ae_evport.c和ae_kqueue.c、ae_select.c这几个文件中。其中ae表示的是antirez eventloop的意思。Redis利用Reactor模式，开发了自己的网络事件处理器，利用I/O多路复用技术监听多个套接字。此框架既实现了高性能的网络">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gmshepard.github.io/2017/03/15/Redis中的事件驱动模型/"/>





  <title>Redis中的事件驱动模型 | gmshepard's tech blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gmshepard's tech blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gmshepard.github.io/2017/03/15/Redis中的事件驱动模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="gmshepard">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gmshepard's tech blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis中的事件驱动模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-15T12:50:23+08:00">
                2017-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Redis服务器是一个单线程服务器，利用I/O多路复用技术实现了一个事件驱动框架。代码在<code>ae.h</code>、<code>ae.c</code>以及<code>ae_epoll.c</code>、<code>ae_evport.c</code>和<code>ae_kqueue.c</code>、<code>ae_select.c</code>这几个文件中。其中ae表示的是antirez eventloop的意思。Redis利用<a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="external">Reactor模式</a>，开发了自己的网络事件处理器，利用I/O多路复用技术监听多个套接字。此框架既实现了高性能的网络通信模型，又很好地与Redis服务器中其它同样以单线程方式运行的模块进行对接，保持了Redis内部单线程的简单性。</p>
<a id="more"></a>
<p>Redis中主要处理两种类型事件：时间事件（aeTimeEvent）和文件事件（aeFileEvent）所有的事件都在一个线程中进行处理，Redis服务器<code>main</code>函数用以下伪代码来表示，这是一个经典的网络编程模型架构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//创建事件循环</span></div><div class="line">  	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">        <span class="comment">// 等待事件到来</span></div><div class="line">        <span class="comment">// 处理事件</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x01-事件模型中的主要数据结构"><a href="#0x01-事件模型中的主要数据结构" class="headerlink" title="0x01 事件模型中的主要数据结构"></a>0x01 事件模型中的主要数据结构</h3><p><code>ae.h</code>中定义了四种主要数据结构</p>
<h4 id="文件事件结构体"><a href="#文件事件结构体" class="headerlink" title="文件事件结构体"></a>文件事件结构体</h4><p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFileEvent &#123;</div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></div><div class="line">    aeFileProc *rfileProc; <span class="comment">// 函数指针，写事件处理</span></div><div class="line">    aeFileProc *wfileProc; <span class="comment">// 函数指针，读事件处理</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 具体的数据</span></div><div class="line">&#125; aeFileEvent;</div></pre></td></tr></table></figure>
<p>其中<code>mask</code>表示文件事件类型掩码，可以是<code>AE_READABLE</code>表示是可读事件，<code>AE_WRITABLE</code>为可写事件。<code>aeFileProc</code>是函数指针。</p>
<h4 id="时间事件结构体"><a href="#时间事件结构体" class="headerlink" title="时间事件结构体"></a>时间事件结构体</h4><p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Time event structure */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeTimeEvent &#123;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">// 事件ID</span></div><div class="line">    <span class="keyword">long</span> when_sec; <span class="comment">// 事件触发的时间:s</span></div><div class="line">    <span class="keyword">long</span> when_ms; <span class="comment">// 事件触发的时间:ms</span></div><div class="line">    aeTimeProc *timeProc; <span class="comment">// 函数指针</span></div><div class="line">    aeEventFinalizerProc *finalizerProc; <span class="comment">// 函数指针:在对应的aeTieEvent节点被删除前调用，可以理解为aeTimeEvent的析构函数</span></div><div class="line">    <span class="keyword">void</span> *clientData; <span class="comment">// 指针，指向具体的数据 </span></div><div class="line">    <span class="keyword">struct</span> aeTimeEvent *next; <span class="comment">// 指向下一个时间事件指针</span></div><div class="line">&#125; aeTimeEvent;</div></pre></td></tr></table></figure>
<p>其中<code>id</code>是服务器为时间事件创建的全局唯一ID。ID号从小到大的顺序递增，新事件比旧事件ID号大。</p>
<p>Redis中的时间事件分为两类：<strong>定时事件</strong>和<strong>周期性事件</strong>。一个时间事件是定时事件还是周期性事件取决于<code>timeProc</code>处理器的返回值，如果返回值为<code>AE_NOMORE</code>，那么这个事件为<strong>定时事件</strong>，等这个事件处理完以后，就会被删除；如果返回一个非<code>AE_NOMORE</code>的整数值，那么服务器会根据这个值更新时间事件的when属性，让此次事件可以再次到达，成为<strong>周期性事件</strong>。</p>
<p>从结构体定义可以看出，服务器将所有时间事件放在一个无序链表里，总将新的事件插入在表头位置。时间执行器执行时，必须遍历整个链表，但这并不会影响服务器性能，目前版本，Redis正常模式下使用的时间事件很少，只有<code>serverCron</code>一个。所以无序链表几乎退化成指针使用。</p>
<h4 id="触发事件结构体"><a href="#触发事件结构体" class="headerlink" title="触发事件结构体"></a>触发事件结构体</h4><p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* A fired event */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeFiredEvent &#123;</div><div class="line">    <span class="keyword">int</span> fd; <span class="comment">// 事件被触发的文件描述符</span></div><div class="line">    <span class="keyword">int</span> mask; <span class="comment">// 被触发事件的掩码，表示被触发事件的类型</span></div><div class="line">&#125; aeFiredEvent;</div></pre></td></tr></table></figure>
<p><code>aeFiredEvent</code>代表已经被触发事件。<code>fd</code>表示事件发生在哪个文件描述符上面，<code>mask</code>用来表示具体事件的类型。</p>
<h4 id="事件循环结构体"><a href="#事件循环结构体" class="headerlink" title="事件循环结构体"></a>事件循环结构体</h4><p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* State of an event based program */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeEventLoop &#123;</div><div class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></div><div class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</div><div class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></div><div class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></div><div class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></div><div class="line">    aeTimeEvent *timeEventHead;</div><div class="line">    <span class="keyword">int</span> stop;</div><div class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></div><div class="line">    aeBeforeSleepProc *beforesleep;</div><div class="line">&#125; aeEventLoop;</div></pre></td></tr></table></figure>
<p><code>aeEventLoop</code>是Redis中事件驱动模型的核心，封装了整个事件循环，其中每个字段解释如下：</p>
<ul>
<li><code>maxfd</code>:已经接受的最大的文件描述符。</li>
<li><code>setsize</code>:当前循环中所能容纳的文件描述符的数量。</li>
<li><code>timeEventNextId</code>:下一个时间事件的ID.</li>
<li><code>lastTime</code>:上一次被访问的时间，用来检测系统时钟是否被修改。</li>
<li><code>events</code>:指针，指向保存所有注册的事件的数组首地址。</li>
<li><code>fired</code>:指针，保存所有已经买被触发的事件的数组首地址。</li>
<li><code>timeEventHead</code>:Redis用一个链表来存储所有的时间事件，timeEventHead是指向这个链表的首节点指针。</li>
<li><code>stop</code>:停止整个事件循环。</li>
<li><code>apiData</code>:指针，指向某一种I/O多路复用结构。</li>
<li><code>beforeSleep</code>:函数指针。每次实现循环的时候，在阻塞直到时间到来之前，会先调用这个函数。</li>
</ul>
<p>事件循环体主要维护I/O事件表，时间事件表和触发时间表。</p>
<h4 id="I-O多路复用结构体"><a href="#I-O多路复用结构体" class="headerlink" title="I/O多路复用结构体"></a>I/O多路复用结构体</h4><p><code>aeApiState</code>这种结构体主要封装了各种I/O多路复用数据结构体，以epoll为例，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> aeApiState &#123;</div><div class="line">    <span class="keyword">int</span> epfd;</div><div class="line">    <span class="keyword">struct</span> epoll_event *events;</div><div class="line">&#125; aeApiState;</div></pre></td></tr></table></figure>
<p><code>epfd</code>保存<code>epoll_create()</code>返回的文件描述符。</p>
<h3 id="0X02-事件驱动原理"><a href="#0X02-事件驱动原理" class="headerlink" title="0X02 事件驱动原理"></a>0X02 事件驱动原理</h3><h4 id="初始化事件循环体"><a href="#初始化事件循环体" class="headerlink" title="初始化事件循环体"></a>初始化事件循环体</h4><p>事件驱动的关键就在于<code>aeEventLoop</code>，<code>aeEventLoop</code>的初始化是在<code>aeCreateEventLoop()</code>方法中进行的，这个方法是在<code>server.c</code>中的<code>initServer()</code>中调用的。实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</div><div class="line">    aeEventLoop *eventLoop;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</div><div class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</div><div class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</div><div class="line">    eventLoop-&gt;setsize = setsize;</div><div class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</div><div class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</div><div class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</div><div class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">// 调用aeApiCreate()初始化epoll相关的数据</span></div><div class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</div><div class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></div><div class="line">     * vector with it. */</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 把每个刚新建的aeFileEvent.mask设置为AE_NONE</div><div class="line">         * 这点是必须的</div><div class="line">         */</div><div class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</div><div class="line">    <span class="keyword">return</span> eventLoop;</div><div class="line"></div><div class="line">err:</div><div class="line">    <span class="keyword">if</span> (eventLoop) &#123;</div><div class="line">        zfree(eventLoop-&gt;events);</div><div class="line">        zfree(eventLoop-&gt;fired);</div><div class="line">        zfree(eventLoop);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>setsize</code>默认值为<code>server.maxclients + RESERVED_FDS+96</code>。</p>
<p>在这个方法中主要就是给<code>aeEventLoop</code>对象分配内存然后并进行初始化。其中关键的地方有：</p>
<ol>
<li><p>调用<code>aeApiCreate()</code>初始化I/O多路复用结构相关的数据。<code>aeApiCreate()</code>实现如下（以<code>epoll</code>为例）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1.分配内存</span></div><div class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</div><div class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="comment">// 1.分配events内存，epoll_event的大小为setsize</span></div><div class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)*eventLoop-&gt;setsize);</div><div class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2.调用epoll_create()生成epoll文件描述符，并保存在epfd这个域中</span></div><div class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</div><div class="line">        zfree(state-&gt;events);</div><div class="line">        zfree(state);</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 把apidata指针指向第一步中分配的内存地址</span></div><div class="line">    eventLoop-&gt;apidata = state;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>aeApiCreate()</code>方法中主要完成以下三件事：</p>
</li>
</ol>
<ul>
<li><p>分配<code>aeApiState</code>结构需要的内存。</p>
</li>
<li><p>调用<code>epoll_create()</code>方法生成epoll的文件描述符，并保存在<code>aeApiState.epfd</code>字段中。</p>
</li>
<li>把第一步分配的<code>aeApiState</code>的内存地址保存在<code>EventLoop-&gt;apidata</code>字段中。</li>
</ul>
<ol>
<li>初始化<code>events</code>中的<code>mask</code>字段为为<code>AE_NONE</code>。</li>
</ol>
<h4 id="开始监听工作"><a href="#开始监听工作" class="headerlink" title="开始监听工作"></a>开始监听工作</h4><p>除了初始化事件循环体，<code>initServer</code>还做了常规网络服务器操作，创建监听socket，绑定端口并启动监听。从下面可以看出，Redis 提供了 TCP 和 UNIX 域套接字两种工作方式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Open the TCP listening socket for the user commands. */</span></div><div class="line"><span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</div><div class="line">    listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">/* Open the listening Unix domain socket. */</span></div><div class="line"><span class="keyword">if</span> (server.unixsocket != <span class="literal">NULL</span>) &#123;</div><div class="line">    unlink(server.unixsocket); <span class="comment">/* don't care if this fails */</span></div><div class="line">    server.sofd = anetUnixServer(server.neterr,server.unixsocket,</div><div class="line">        server.unixsocketperm, server.tcp_backlog);</div><div class="line">    <span class="keyword">if</span> (server.sofd == ANET_ERR) &#123;</div><div class="line">        serverLog(LL_WARNING, <span class="string">"Opening Unix socket: %s"</span>, server.neterr);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    anetNonBlock(<span class="literal">NULL</span>,server.sofd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="为监听套接字注册事件"><a href="#为监听套接字注册事件" class="headerlink" title="为监听套接字注册事件"></a>为监听套接字注册事件</h4><p>在进入事件循环前还需要做一些准备工作。紧接着，<code>initServer()</code> 为所有的监听套接字注册了读事件（读事件表示有新的连接到来），响应函数为<code>acceptTcpHandler()</code>或者<code>acceptUnixHandler()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></div><div class="line">     * domain sockets. */</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</div><div class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</div><div class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</div><div class="line">            &#123;</div><div class="line">                serverPanic(</div><div class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (server.sofd &gt; <span class="number">0</span> &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</div><div class="line">        acceptUnixHandler,<span class="literal">NULL</span>) == AE_ERR) serverPanic(<span class="string">"Unrecoverable error creating server.sofd file event."</span>);</div><div class="line"><span class="comment">// 用于 TCP 接收请求的处理函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</div><div class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN];</div><div class="line">    UNUSED(el);</div><div class="line">    UNUSED(mask);</div><div class="line">    UNUSED(privdata);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(max--) &#123;</div><div class="line">      	<span class="comment">//接受客户端的请求</span></div><div class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</div><div class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</div><div class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">                serverLog(LL_WARNING,</div><div class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        serverLog(LL_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</div><div class="line">        acceptCommonHandler(cfd,<span class="number">0</span>,cip);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当接受了客户端请求，再调用<code>acceptCommonHandler()</code>,这个函数主要做两件事：</p>
<ul>
<li>保存服务端与客户端连接信息</li>
<li>为客户端连接套接字注册读事件相应的回调函数为 <code>readQueryFromClient()</code>， <code>readQueryFromClient()</code> 作用是从套接字读取数据，执行相应操作并回复客户端。</li>
</ul>
<p>注册事件有两个函数，一个是注册文件事件，一个是注册时间事件。注册时间事件函数没什么值得提的，下面介绍一下注册文件事件函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></div><div class="line">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 1. 检查新增的fd是否超过所能容纳最大值</span></div><div class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</div><div class="line">        errno = ERANGE;</div><div class="line">        <span class="keyword">return</span> AE_ERR;</div><div class="line">    &#125;</div><div class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</div><div class="line"></div><div class="line">    <span class="comment">// 2. 调用aeApiAddEvent()方法把对应的fd以mask模式添加到epoll监听器中</span></div><div class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</div><div class="line">        <span class="keyword">return</span> AE_ERR;</div><div class="line">    <span class="comment">// 3. 设置相应的字段值</span></div><div class="line">    fe-&gt;mask |= mask;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</div><div class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</div><div class="line">    fe-&gt;clientData = clientData;</div><div class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</div><div class="line">        <span class="comment">// 如果有需要则修改maxfd字段的值</span></div><div class="line">        eventLoop-&gt;maxfd = fd;</div><div class="line">    <span class="keyword">return</span> AE_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>aeCreateFileEvent()</code>方法主要做了一下三件事:</p>
<ul>
<li><p>检查新增的fd是否超过所能容纳最大值。</p>
</li>
<li><p>调用<code>aeApiAddEvent()</code>方法把对应的fd以mask模式添加到epoll监听器中。</p>
</li>
<li><p>设置相应的字段值。</p>
</li>
</ul>
<p>其中最关键的步骤是第二步，<code>aeApiAddEvent()</code>方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">aeApiState *state = eventLoop-&gt;apidata;</div><div class="line"><span class="keyword">struct</span> epoll_event ee = &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></div><div class="line"><span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></div><div class="line"> * operation. Otherwise we need an ADD operation. */</div><div class="line"><span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</div><div class="line">        EPOLL_CTL_ADD : EPOLL_CTL_MOD;</div><div class="line"></div><div class="line">ee.events = <span class="number">0</span>;</div><div class="line">mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></div><div class="line"><span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</div><div class="line"><span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</div><div class="line">ee.data.fd = fd;</div><div class="line"><span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="进入事件循环"><a href="#进入事件循环" class="headerlink" title="进入事件循环"></a>进入事件循环</h4><p>做好准备工作后，可以进入事件循环。跳出<code>initServer()</code> 回到<code>main()</code> 中，<code>main()</code>会 调用<code>aeMain()</code>。进入事件循环发生在 <code>aeProcessEvents()</code> 中。先看<code>aeMain()</code>的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</div><div class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</div><div class="line">            eventLoop-&gt;beforesleep(eventLoop);</div><div class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>真正处理在<code>aeProcessEvents()</code>函数中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></div><div class="line"> * (that may be registered by time event callbacks just processed).</div><div class="line"> * Without special flags the function sleeps until some file event</div><div class="line"> * fires, or when the next time event occurs (if any).</div><div class="line"> *</div><div class="line"> * If flags is 0, the function does nothing and returns.</div><div class="line"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</div><div class="line"> * if flags has AE_FILE_EVENTS set, file events are processed.</div><div class="line"> * if flags has AE_TIME_EVENTS set, time events are processed.</div><div class="line"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</div><div class="line"> * the events that's possible to process without to wait are processed.</div><div class="line"> *</div><div class="line"> * The function returns the number of events processed. */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 既没有时间事件也没有文件事件，则直接返回</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * -1 == eventloop-&gt;maxfd 表示还么有任何aeFileEvent被添加到epoll    </div><div class="line">     * 事件循环中进行监听</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</div><div class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</div><div class="line">        <span class="keyword">struct</span> timeval tv, *tvp;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 如果有aeFileEvent需要处理，就先要从所有待处理的</div><div class="line">         * aeTimeEvent事件中找到最近的将要被执行的aeTimeEvent节点</div><div class="line">         * 并结算该节点触发时间</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</div><div class="line">            shortest = aeSearchNearestTimer(eventLoop);</div><div class="line">        <span class="keyword">if</span> (shortest) &#123;</div><div class="line">            <span class="keyword">long</span> now_sec, now_ms;</div><div class="line"></div><div class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">            tvp = &amp;tv;</div><div class="line"></div><div class="line">            <span class="comment">/* How many milliseconds we need to wait for the next</span></div><div class="line">             * time event to fire? */</div><div class="line">            <span class="comment">// 计算epoll_wait()需要等待的时间</span></div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</div><div class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</div><div class="line">                shortest-&gt;when_ms - now_ms;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</div><div class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</div><div class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</div><div class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 如果flags设置了AE_DONT_WAIT,则设置epoll_wait()等待时间为0，</span></div><div class="line">            <span class="comment">// 即立刻从epoll中返回</span></div><div class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</div><div class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</div><div class="line">                tvp = &amp;tv;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">/* Otherwise we can block */</span></div><div class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 调用aeApiPoll()进行阻塞等待事件的到来，等待时间为tvp</span></div><div class="line">        numevents = aeApiPoll(eventLoop, tvp);</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</div><div class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</div><div class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</div><div class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</div><div class="line">            <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></div><div class="line">             * event removed an element that fired and we still didn't</div><div class="line">             * processed, so we check if the event is still valid. */</div><div class="line">            <span class="comment">// fe-&gt;mask &amp;&amp; mask 的目的是确保对应事件时候还有效</span></div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</div><div class="line">                rfired = <span class="number">1</span>;</div><div class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</div><div class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</div><div class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</div><div class="line">            &#125;</div><div class="line">            processed++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Check time events */</span></div><div class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</div><div class="line">        <span class="comment">// 处理aeTimeEvent</span></div><div class="line">        processed += processTimeEvents(eventLoop);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法的入参<code>flag</code>表示要处理哪些事件，可以取以下几个值 ：</p>
<ul>
<li><code>AE_ALL_EVENTS</code>:<code>timeEvent</code>和<code>fileEvent</code>都会处理。</li>
<li><code>AE_FILE_EVENTS</code>:只处理<code>fileEvent</code>。</li>
<li><code>AE_TIME_EVENTS</code>:只处理<code>timeEvent</code>。</li>
<li><code>AE_DONT_WAIT</code>:要么立马返回，要么处理完那些不需要等待的事件之后再立马返回。</li>
</ul>
<p><code>aeProcessEvents()</code>方法会做下面几件事:</p>
<ol>
<li>判断传入的<code>flag</code>的值，如果既不包含<code>AE_TIME_EVENTS</code>也不包含<code>AE_FILE_EVENTS</code>则直接返回。</li>
<li>计算如果有<code>aeTimeEvent</code>事件需要进行处理，则先计算<code>epoll_wait()</code>方法需要阻塞等待的时间，计算方式如下:<br>{0}. 先从<code>aeTimeEvent</code>事件链表中找到最近的需要被触发的<code>aeTimeEvent</code>节点并计算需要被触发的时间，该被触发时间则为<code>epoll_wait()</code>需要等待的时间。<br>{0}. 如果没有找到最近的<code>aeTimeEvent</code>节点，表示没有<code>aeTimeEvent</code>节点被加入链表，则判断传入的<code>flags</code>是否包含<code>AE_DONT_WAIT</code>选项，则设置<code>epoll_wait()</code>需要等待时间为0，表示立即返回。<br>{0}. 如果没有设置<code>AE_DONT_WAIT</code>,则设置需要等待时间为<code>NULL</code>,表示<code>epoll_wait()</code>一直阻塞等待知道有<code>fileEvent</code>事件到来。</li>
<li>调用<code>aeApiPoll()</code>方法阻塞等待事件的到来，阻塞时间为第二步中计算的时间。<code>aeApiPoll()</code>实现如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> </span>&#123;</div><div class="line">    aeApiState *state = eventLoop-&gt;apidata;</div><div class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 1. 根据传入的tvp计算需要等待时间，然后调用epoll_wait()进行阻塞等待</span></div><div class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</div><div class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</div><div class="line">    <span class="comment">// 有事件到来</span></div><div class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line"></div><div class="line">        numevents = retval;</div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</div><div class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</div><div class="line">            <span class="keyword">struct</span> epoll_event *e = state-&gt;events+j;</div><div class="line"></div><div class="line">            <span class="comment">// 2. 计算到来的event的类型</span></div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</div><div class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</div><div class="line"></div><div class="line">            <span class="comment">// 3. 把有事件发生的fd以及对应的mask类型拷贝到eventloop-&gt;fired数组中</span></div><div class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</div><div class="line">            eventLoop-&gt;fired[j].mask = mask;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> numevents;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <code>aeApiPoll()</code>会做下面几件事:</p>
<ul>
<li>根据传入的<code>tvp</code>计算需要阻塞的时间，然后调用<code>epoll_wait()</code>进行阻塞等待。</li>
<li>有事件到来之后先计算对应事件的类型。</li>
<li>把事件发生的fd以及对应的类型mask拷贝到<code>fired</code>数组中。</li>
</ul>
<ol>
<li>从<code>aeApiPoll()</code>方法返回之后，所有事件已经就绪了的fd以及对应事件的类型mask已经保存在<code>eventLoop-&gt;fired[]</code>数组中。依次遍历<code>fired</code>数组，根据mask类型，执行对应的<code>rfileProc()</code>或者<code>wfileProce()</code>方法。</li>
<li>如果传入的flags中有<code>AE_TIME_EVENTS</code>,则调用<code>processTimeEvents()</code>执行所有已经到时间了的时间事件。<code>processTimeEvents()</code>结构如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</div><div class="line">    aeTimeEvent *te, *prev;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</div><div class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果系统时间被调整到将来某段时间然后又被设置回正确的时间,</div><div class="line">     * 这种情况下链表中的timeEvent有可能会被随机的延迟执行,因</div><div class="line">     * 此在这个情况下把所有的timeEvent的触发时间设置为0表示及执行</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</div><div class="line">        te = eventLoop-&gt;timeEventHead;</div><div class="line">        <span class="keyword">while</span>(te) &#123;</div><div class="line">            te-&gt;when_sec = <span class="number">0</span>;</div><div class="line">            te = te-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    eventLoop-&gt;lastTime = now; <span class="comment">// 设置上次运行时间为now</span></div><div class="line"></div><div class="line">    prev = <span class="literal">NULL</span>;</div><div class="line">    te = eventLoop-&gt;timeEventHead;</div><div class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</div><div class="line">    <span class="keyword">while</span>(te) &#123;</div><div class="line">        <span class="keyword">long</span> now_sec, now_ms;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 删除已经被标志位 删除 的时间事件</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</div><div class="line">            aeTimeEvent *next = te-&gt;next;</div><div class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</div><div class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                prev-&gt;next = te-&gt;next;</div><div class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</div><div class="line">                <span class="comment">// 在时间事件节点被删除前调用finlizerProce()方法</span></div><div class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</div><div class="line">            zfree(te);</div><div class="line">            te = next;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * te-&gt;id &gt; maxId 表示当前te指向的timeEvent为当前循环中新添加的,</div><div class="line">             * 对于新添加的节点在本次循环中不作处理。</div><div class="line">             * PS:为什么会出现这种情况呢？有可能是在timeProc()里面会注册新的timeEvent节点?</div><div class="line">             * 对于当前的Redis版本中不会出现te-&gt;id &gt; maxId这种情况</div><div class="line">             */</div><div class="line">            te = te-&gt;next;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</div><div class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</div><div class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 如果当前时间已经超过了对应的timeEvent节点设置的触发时间，</span></div><div class="line">            <span class="comment">// 则调用timeProc()方法执行对应的任务</span></div><div class="line">            <span class="keyword">int</span> retval;</div><div class="line"></div><div class="line">            id = te-&gt;id;</div><div class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</div><div class="line">            processed++;</div><div class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</div><div class="line">                <span class="comment">// 要执行多次，则计算下次执行时间</span></div><div class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果只需要执行一次，则把id设置为-1，再下次循环中删除</span></div><div class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        prev = te;</div><div class="line">        te = te-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> processed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中会判断系统时间有没有调整过，如果调整过，则会把timeEvent链表中的所有的timeEvent的触发时间设置为0，表示立即执行。对timeEvent链表进行遍历，对于每个节点，如果已经被标记为删除(<code>AE_DELETED_EVENT_ID</code>)，则立即释放对应节点内存，遍历下个节点。如果id大于maxId,则表示当前节点为本次循环中新增节点，本次循环中不作处理，继续下个节点。如果当前节点的触发时间大于当前时间，则调用对应节点的timeProc()方法执行任务。返回值来判定是周期事件还是定时事件。</p>
<h4 id="请求的处理流程"><a href="#请求的处理流程" class="headerlink" title="请求的处理流程"></a>请求的处理流程</h4><p>前面说过服务器会为连接套接字注册<code>readQueryFromClient()</code>回调函数，当请求过来时，这个函数会被调用。它会调用<code>processInputBuffer()</code>解析命令和执行命令，对于命令的执行，调用的是函数<code>processCommand()</code>。下面是<code>processCommand()</code>核心代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123; </div><div class="line">  ...... </div><div class="line">  <span class="comment">// 查找命令，redisClient.cmd 在此时赋值 </span></div><div class="line">  <span class="comment">/* Now lookup the command and check ASAP about trivial error conditions </span></div><div class="line">  * such as wrong arity, bad command name and so forth. */</div><div class="line">  c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">  <span class="comment">// 没有找到命令 </span></div><div class="line">  <span class="keyword">if</span> (!c-&gt;cmd) &#123;</div><div class="line">  	flagTransaction(c);</div><div class="line">  	addReplyErrorFormat(c,<span class="string">"unknown command '%s'"</span>, (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</div><div class="line">  	<span class="keyword">return</span> REDIS_OK;</div><div class="line"><span class="comment">// 参数个数不符合 </span></div><div class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) || (c-&gt;argc &lt; c-&gt;cmd-&gt;arity)) &#123;</div><div class="line">	flagTransaction(c);</div><div class="line">	addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>, c-&gt;cmd-&gt;name);</div><div class="line">	<span class="keyword">return</span> REDIS_OK; </div><div class="line"> &#125;</div><div class="line"> .....</div><div class="line"> <span class="comment">// 加入命令队列的情况 /* Exec the command */ </span></div><div class="line"> <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp; c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp; c-&gt;cmd-&gt;proc != 			 	multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)&#123; </div><div class="line">   <span class="comment">// 命令入队</span></div><div class="line">   queueMultiCommand(c); </div><div class="line">   addReply(c,shared.queued);</div><div class="line">   <span class="comment">// 真正执行命令。 // 注意，如果是设置了多命令模式，那么不是直接执行命令，而是让命令入队 </span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   call(c,REDIS_CALL_FULL); </div><div class="line">   <span class="keyword">if</span> (listLength(server.ready_keys)) </div><div class="line">     handleClientsBlockedOnLists();</div><div class="line">&#125; </div><div class="line">  <span class="keyword">return</span> REDIS_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上可以看到，Redis 首先根据客户端给出的命令字在命令表中查找对应的 c-&gt;cmd, 即 <code>struct redisCommand()</code>。Redis 在初始化的时候准备了一个大数组，初始化了所有的命令，即初始化多个<code>struct redisCommand</code>，在<code>struct redisCommand</code>中就有该命令对应的回调函数指针。找到命令结构体后，则开始执行命令，核心调用是<code>call()</code>。</p>
<p>执行命令内的流程很多，要对命令的参数进行检测，要看键值是否过期等等，这里就不在赘述。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/事件驱动/" rel="tag"># 事件驱动</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/02/数据库索引简介/" rel="next" title="数据库索引简介">
                <i class="fa fa-chevron-left"></i> 数据库索引简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/15/Redis空间引擎设计/" rel="prev" title="Redis空间引擎设计">
                Redis空间引擎设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="gmshepard" />
          <p class="site-author-name" itemprop="name">gmshepard</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01-事件模型中的主要数据结构"><span class="nav-number">1.</span> <span class="nav-text">0x01 事件模型中的主要数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件事件结构体"><span class="nav-number">1.1.</span> <span class="nav-text">文件事件结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间事件结构体"><span class="nav-number">1.2.</span> <span class="nav-text">时间事件结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触发事件结构体"><span class="nav-number">1.3.</span> <span class="nav-text">触发事件结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#事件循环结构体"><span class="nav-number">1.4.</span> <span class="nav-text">事件循环结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O多路复用结构体"><span class="nav-number">1.5.</span> <span class="nav-text">I/O多路复用结构体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0X02-事件驱动原理"><span class="nav-number">2.</span> <span class="nav-text">0X02 事件驱动原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化事件循环体"><span class="nav-number">2.1.</span> <span class="nav-text">初始化事件循环体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开始监听工作"><span class="nav-number">2.2.</span> <span class="nav-text">开始监听工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为监听套接字注册事件"><span class="nav-number">2.3.</span> <span class="nav-text">为监听套接字注册事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进入事件循环"><span class="nav-number">2.4.</span> <span class="nav-text">进入事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求的处理流程"><span class="nav-number">2.5.</span> <span class="nav-text">请求的处理流程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">gmshepard</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
